library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity quantizer is
	generic(
		MAC_MAX : natural := 100;
		NBITS : 6;
		NACC : 11
	);
	port(
		clk : in std_logic;
		rstB : in std_logic;
		in_a : in std_logic_vector(2*NBITS+NACC-1 downto 0);
		in_b : in std_logic_vector(2*NBITS+NACC-1 downto 0);
		res : out std_logic_vector(NBITS-1 downto 0)
	);
end entity quantizer

architecture rtl of quantizer is

	constant QUANT_MAX : integer :=  31; -- 1.9375 * 16
	constant QUANT_MIN : integer := -32; -- -2 * 16
	constant HS_MAX 	 : integer :=  16; -- 1 * 16
	constant HS_MIN    : integer :=   0; -- 0 * 16
	constant HT_MAX    : integer :=  16; -- 1 * 16
	constant HT_MIN	 : integer := -16; -- -1 * 16
	 -- branched to accumulators with output registers --> no need to add an input register
	 --mode : "00" --> quantize
	 --       "01" --> relu
	 --       "10" --> hard_sigmoid
	 --		 "11" --> hard_tanh
	signal res_reg, res_next : std_logic_vector(NBITS-1 downto 0);
	signal mode : std_logic_vector(1 downto 0);
begin

	REG: process(clk, rstB)
	begin
		if rstB = '0' then
			res_reg <= (others => '0');
		elsif rising_edge(clk) thenÂ¨
			res_reg <= res_next;
		end if;
	end process;
	
	in_mux_max <= QUANT_MAX when mode = "00",
						(others => '0') when mode = "01",
					  HS_MAX when mode = "10",
					  HT_MAX when mode = "11",
					  
				
	in_mux_min <= QUANT_MIN when mode = "00",
					  HS_MIN when mode = "01",
					  HT_MIN when mode = "11"
	out_mux : process()
	begin
	
	end process;
end architecture;
 

	